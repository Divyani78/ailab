import networkx as nx
import matplotlib.pyplot as plt
from collections import deque
import time

class RouteFinder:
    def __init__(self):
        self.graph = nx.Graph()
        
    def add_road(self, intersection1, intersection2, distance=1):
        """Add a road between two intersections with given distance."""
        self.graph.add_edge(intersection1, intersection2, weight=distance)

    def bidirectional_bfs(self, start, end):
        """Implement bi-directional BFS to find shortest path."""
        if start == end:
            return [start]
        
        
        forward_queue = deque([(start, [start])])
        backward_queue = deque([(end, [end])])
        
        forward_visited = {start: [start]}
        backward_visited = {end: [end]}
        
        while forward_queue and backward_queue:
           
            current, path = forward_queue.popleft()
            for neighbor in self.graph.neighbors(current):
                if neighbor in backward_visited:
                    forward_path = path
                    backward_path = backward_visited[neighbor]
                    return forward_path + backward_path[::-1][1:]
                
                if neighbor not in forward_visited:
                    forward_visited[neighbor] = path + [neighbor]
                    forward_queue.append((neighbor, path + [neighbor]))
            
            current, path = backward_queue.popleft()
            for neighbor in self.graph.neighbors(current):
                if neighbor in forward_visited:
                    forward_path = forward_visited[neighbor]
                    backward_path = path
                    return forward_path + backward_path[::-1][1:]
                
                if neighbor not in backward_visited:
                    backward_visited[neighbor] = path + [neighbor]
                    backward_queue.append((neighbor, path + [neighbor]))
        
        return None 

    def standard_bfs(self, start, end):
        """Implement standard BFS for comparison."""
        queue = deque([(start, [start])])
        visited = {start}
        
        while queue:
            current, path = queue.popleft()
            if current == end:
                return path
                
            for neighbor in self.graph.neighbors(current):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))
        
        return None

    def visualize_path(self, path, title="Route Visualization"):
        """Visualize the found path using networkx."""
        pos = nx.spring_layout(self.graph)
        
      
        plt.figure(figsize=(10, 8))
        nx.draw_networkx_nodes(self.graph, pos, node_color='lightblue', 
                             node_size=500)
        nx.draw_networkx_edges(self.graph, pos, edge_color='gray')
        nx.draw_networkx_labels(self.graph, pos)
        
       
        if path:
            path_edges = list(zip(path[:-1], path[1:]))
            nx.draw_networkx_edges(self.graph, pos, edgelist=path_edges, 
                                 edge_color='r', width=2)
            nx.draw_networkx_nodes(self.graph, pos, nodelist=path,
                                 node_color='lightgreen', node_size=500)
        
        plt.title(title)
        plt.axis('off')
        plt.show()

    def compare_performance(self, start, end, num_trials=100):
        """Compare performance of bi-directional BFS vs standard BFS."""
        start_time = time.time()
        for _ in range(num_trials):
            bi_path = self.bidirectional_bfs(start, end)
        bi_time = (time.time() - start_time) / num_trials

        start_time = time.time()
        for _ in range(num_trials):
            std_path = self.standard_bfs(start, end)
        std_time = (time.time() - start_time) / num_trials

        return {
            'bidirectional_time': bi_time,
            'standard_time': std_time,
            'bidirectional_path': bi_path,
            'standard_path': std_path
        }

def main():
    route_finder = RouteFinder()
    
    roads = [
        ('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'),
        ('A', 'F'), ('F', 'G'), ('G', 'H'), ('H', 'E'),
        ('B', 'G'), ('C', 'H'), ('F', 'C')
    ]
    
    for road in roads:
        route_finder.add_road(*road)
    
    start, end = 'A', 'E'
    
    results = route_finder.compare_performance(start, end)
    
    print(f"\nPerformance Comparison (averaged over 100 trials):")
    print(f"Bi-directional BFS time: {results['bidirectional_time']*1000:.2f} ms")
    print(f"Standard BFS time: {results['standard_time']*1000:.2f} ms")
    print(f"\nBi-directional BFS path: {' -> '.join(results['bidirectional_path'])}")
    print(f"Standard BFS path: {' -> '.join(results['standard_path'])}")
    
    route_finder.visualize_path(results['bidirectional_path'], 
                              "Bi-directional BFS Route")

if __name__ == "__main__":
    main()
